
# This file is the composite schema definition. 

# To convert it to a composite:
# composedb composite:create source-schema.graphql --output=my-composite.json
# https://composedb.js.org/docs/0.3.x/guides/creating-composites/overview#converting-a-schema-to-a-composite

# The composite can then be uploaded to a Ceramic node:
# composedb composite:deploy my-first-composite.json --ceramic-url=http://localhost:7007

# To start GraphQL server, convert the encoded composite to a runtime definition:
# composedb composite:compile my-first-composite.json runtime-composite.json
# composedb graphql:schema runtime-composite.json # Print the runtime-composite 
# composedb graphql:server --ceramic-url=http://localhost:7007 --graphiql --port=5001 runtime-composite.json
# https://composedb.js.org/docs/0.3.x/first-composite


# No Timestamp, bigInt. Check the available scalars
# for the right names


type NounsProposal @createModel(accountRelation: LIST, description: "Table containing 
information about proposals made in a voting system") {
  blocknumber: Int! @int(min: 1)
  created_timestamp: Int! @int(min: 1)
  votes_abstain: Int! @int(min: 1)
  distinct_votes_abstain: Int! @int(min: 1)
  unique_holders: Int! @int(min: 1)
  total_supply: Int! @int(min: 1)
  proposal_id: Int! @int(min: 1)
  requested_eth: Int! @int(min: 1)
  start_block: Int! @int(min: 1)
  end_block: Int! @int(min: 1)
  total_votes: Int! @int(min: 1)
  total_distinct_voters: Int! @int(min: 1)
  quorum_required: Int! @int(min: 1)
  votes_for: Int! @int(min: 1)
  distinct_voters_for: Int! @int(min: 1)
  votes_against: Int! @int(min: 1)
  distinct_voters_against: Int! @int(min: 1)
  proposer: String! @string(maxLength:256)
  transactionhash: String! @string(maxLength:256)
  ens: String! @string(maxLength:256)
  description: String! @string(maxLength:256)
  state: String! @string(maxLength:256)
}


